Broad phasing

List/Array of all "Bodies" in the game



Loop of physics engine

apply forces

update postions and velocities

detect collisions (collision detection)

solve constraints

display results (render)


analogous means compairable


Particle system simulation:

delta time

Force to apply
Each particle has mass, position, velocity

velocity(new frame) = velocity(old frame) + (force(old frame) / mass) * dt
position(new frame) = position(old frame) + velocity(new frame) * dt


Rigid body simulation:

Extension of particle, extra is volume, shape and ability to rotate

Rigid body naturally rotates around centre of MASS

Initial state of rigid body with centre of mass at origin and rotation angle
of zero

its position and rotation at any instant of time, is an offset of
the initial state


centre of mass is the mid-point of mass distribution of a body

rigid body has a mass M made up of N tiny marticles, each with a mass and location
within the body

centre of mass can be computed as

Total of all mass * locations within the rigid body
divided by the rigid bodys total mass

Sum (mass * location)
---------------
	MASS

Rigid bodies are made up of a continuous number of discrete particles

Calculate using the integral instead of finite

(1 / M) * integral * p (gives density at location) * location * density? * Volume

Since they can rotate, introduce angular properties

In 2D, rigid body can only rotate about the axis that points out of the screen
therefore only need one scalar to represent its orientation
Usually use radians (go from 0 - 2*pi) instead of angles (0 - 360)
as it simplifies calculations

To rotate, rigid body needs some angular velocity, which is a scalar with unit
radians per second commonly represented by omega
To gain angular velocity the body needs to recieve some rotational force - torque

represented by tau.
Applying Newton's second law

Torque = moment of Inertia * angular acceleration

For rotation, the moment of Inertia is analogous to mass for linear motion
Defines how hard it is to change angular velocity of rigid body
In 2D it's a scalar and defined as

Moment of Inertia = 
integral * p (gives density at location) * dot product of location
 * density? * V - performed for all points throughout the body volume
r is position vector of each point relative to axis of rotation

Moment of inertia for square where origin is centre:

Moment of inertia = (mass(height^2 + width^2) /  12)


When force is applied to point of rigid body it may produce torque.
In 2D the torque is a scalar. and the torque generated by a force
applied at a point on the body which has an offset vector from center of mass
is
absolute of offset vector (r) and force (f)
Torque = offset vector * force * sin(smallest angle between f and r)

In 3 dimensions can do this

Torque = r * f

2D simulation can be seen as 3D where all rigid bodies are thin/flat and it
all happens on the xy-plane. Meaning no movement in Z axis

This means f and r are always in the xy plane. And so Torque will always have
zero x and y components because cross product will always be perpendicular
to xy-plane. This means it will always be parallel to the z-axis
Thus only the z component of the cross product matters.
This means the calculation of torque in 2 dimentions can be simplified to
Torque = r.x * f.y - r.y * f.x


Broad phasing:

The sort and Sweep algorithm

In the algorithm, we insert all X values for AABB - min and max

then sort it ascending by scalar values

then we sweep the list
whenever a min value is encountered its corresonding interval is stored
in a separate list of active intervals
whenever a max value is encountered, its corresponding interval is removed from the
list of active intervals.
At any moment, all the active intervals are intersecting
The list of intervals can be reused on each step of simulation
where we can efficiently re-sort this list using insertion sort, because
it's good for nearly-sorted lists

In 2D and 3D, running sort and sweep, as described above, over a single coordinate
axis will reduce number of direct aabb intersection tests
that need to be performed
but the payoff could be better over one axis than another


Dynamic bounding volume tree:
Binary tree where each node has an AABB that bounds all the AABBs of its children

The AABBs of rigid bodies are located in leaf nodes

typically a Dbvt is "queried" by giving the AABB for which we want to
detect intersections

This is efficient because the children of nodes that don't intersect the
queried AABB don't need to be tested for overlap

As such an AABB collision query starts from the root, and continues
recursively through the tree only for AABB nodes
that intersect with the queried AABB


Narrow Phase:
After broad phase - sets of pairs of rigid bodies that are potentially colliding

Therefore we must test for each pair if they're colliding or not

Also need to know the points of contact between the colliding bodies
to help resolve collisions













